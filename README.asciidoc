= That's Interesting

*That's interesting* is a strongly typed logging framework targeting applications that want to aggregate their log messages into a single system, such as the ever famous ELK stack.

== Usage

The framework works by defining logger interfaces (called "point of interest") such as: 

[source, java]
----
package your.own.package

public interface YourOwnPOI {

    void somethingInteresting(YourPOJO pojo);

}
----

You use that interface together with the `Interested` class like this to create an instance at runtime:

[source, java]
----
import static de.xn__ho_hia.interesting.handler.StandardInvocationHandlers.systemOut;

import de.xn__ho_hia.interesting.Interested;

YourOwnPOI poi = Interested.in(YourOwnPOI.class)
                .invocationHandler(systemOut())
                .createLogger();
----

Finally, use the created instance at runtime to log something that is of interest to your application:

[source, java]
----
poi.somethingInteresting(pojo);
----

With its current default settings the above call will result in something like this on `System.out`:

[source]
----
Class: [your.own.package.YourOwnPOI] Method: [somethingInteresting] Arguments: [pojo: {field1: value1, field2: value2}]
----

You probably don't want to write to `System.out` but log into a file on your filesystem like this:

[source]
----
import static de.xn__ho_hia.interesting.handler.StandardInvocationHandlers.logFile;
import de.xn__ho_hia.interesting.LoggerBuilder;

YourOwnPOI poi = new LoggerBuilder<>(YourOwnPOI.class)
                .invocationHandler(logFile("target/file.log"))
                .createLogger();
----

However that is still no fun since you probably want to aggregate all your logs from all your applications in a central place like an Elasticsearch cluster or your next best Kafka broker. Users of the ELK stack can ignore Logstash and push directly into ES like this:

[source, java]
----
import static de.xn__ho_hia.interesting.handler.ElasticsearchInvocationHandlers.elasticsearch;
import de.xn__ho_hia.interesting.LoggerBuilder;

YourOwnPOI poi = new LoggerBuilder<>(YourOwnPOI.class)
                .invocationHandler(elasticsearch("localhost:9300"))
                .createLogger();
----

The above configuration sends objects similar to the following JSON:

[source, json]
----
{
  "class": "your.own.package.YourOwnPOI",
  "method": "somethingInteresting",
  "arguments": {
    "pojo": {
      "field1": "value1",
      "field2": "value2"
    }
  }
}
----

If you want to add additional key-value pairs, do the following:

[source, java]
----
import static de.xn__ho_hia.interesting.handler.ElasticsearchInvocationHandlers.elasticsearch;
import de.xn__ho_hia.interesting.LoggerBuilder;

YourOwnPOI poi = new LoggerBuilder<>(YourOwnPOI.class)
                .invocationHandler(elasticsearch("localhost:9300", "indexName"))
                .withStaticExtra("application", "yourCoolApp")
                .withStaticExtra("hostname", "your.custom.domain.tld")
                .withSuppliedExtra("timestamp", () -> LocalDateTime.now().toString())
                .createLogger();
----

Which then produces:

[source, json]
----
{
  "class": "your.own.package.YourOwnPOI",
  "method": "somethingInteresting",
  "arguments": {
    "pojo": {
      "field1": "value1",
      "field2": "value2"
    }
  },
  "application": "yourCoolApp",
  "hostname": "your.custom.domain.tld",
  "timestamp": "your-local-date-time"
}
----

== Tips & Tricks

Configuring your points of interest outside of the classes that are using those has the advantage that none of the using classes have a compile time dependency on any classes in this library.
